export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string. */
  BigInt: any;
  Blob: any;
  /** A datetime type, encoded in ISO 8601 string in JSON, or timestamp type in MessagePack */
  DateTime: any;
};

/** Personal access tokens */
export type AccessToken = Node & {
  __typename?: "AccessToken";
  createdAt: Scalars["DateTime"];
  description: Scalars["String"];
  descriptionHtml: Scalars["String"];
  id: Scalars["ID"];
  /** It returns true if (1) the access token is not revoked, and (2) the author of the access token is alive. */
  isActive: Scalars["Boolean"];
  isRevoked: Scalars["Boolean"];
  lastUsedAt?: Maybe<Scalars["DateTime"]>;
  logs: AccessTokenLogConnection;
  path: Scalars["String"];
  scopes: Array<AccessTokenScope>;
  title: Scalars["String"];
  /** The secret token value, which is only available via `createAccessToken` mutation. */
  token?: Maybe<Scalars["String"]>;
  updatedAt: Scalars["DateTime"];
  /** The author of the access token */
  user: User;
};

/** Personal access tokens */
export type AccessTokenLogsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The connection type for AccessToken. */
export type AccessTokenConnection = {
  __typename?: "AccessTokenConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccessTokenEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AccessToken>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type AccessTokenEdge = {
  __typename?: "AccessTokenEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<AccessToken>;
};

/** Usage logs for personal access tokens */
export type AccessTokenLog = Node & {
  __typename?: "AccessTokenLog";
  accessToken: AccessToken;
  createdAt: Scalars["DateTime"];
  id: Scalars["ID"];
  ipAddress: Scalars["String"];
  operationType: Scalars["String"];
  query: Scalars["String"];
  user: User;
  userAgent: Scalars["String"];
};

/** The connection type for AccessTokenLog. */
export type AccessTokenLogConnection = {
  __typename?: "AccessTokenLogConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccessTokenLogEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AccessTokenLog>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type AccessTokenLogEdge = {
  __typename?: "AccessTokenLogEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<AccessTokenLog>;
};

export enum AccessTokenScope {
  Read = "READ",
  Write = "WRITE",
  Administer = "ADMINISTER",
}

/** Autogenerated input type of ArchiveFolder */
export type ArchiveFolderInput = {
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of ArchiveFolder */
export type ArchiveFolderPayload = {
  __typename?: "ArchiveFolderPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  folder: Folder;
};

/** Autogenerated input type of ArchiveGroup */
export type ArchiveGroupInput = {
  groupId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of ArchiveGroup */
export type ArchiveGroupPayload = {
  __typename?: "ArchiveGroupPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  group: Group;
};

/** Autogenerated input type of ArchiveNote */
export type ArchiveNoteInput = {
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of ArchiveNote */
export type ArchiveNotePayload = {
  __typename?: "ArchiveNotePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  note: Note;
};

export type Attachment = Node & {
  __typename?: "Attachment";
  author: User;
  createdAt: Scalars["DateTime"];
  /** The data of the attachment in binary. Prefer `data_url` if you use JSON for serializers */
  data: Scalars["Blob"];
  /** The same value as `data` but encoded in data URL schema */
  dataUrl: Scalars["String"];
  id: Scalars["ID"];
  key: Scalars["String"];
  kind: AttachmentKind;
  /** A MIME type detected from its data and name */
  mimeType: Scalars["String"];
  name: Scalars["String"];
  path: Scalars["String"];
  /** The file size */
  size: Scalars["Int"];
  url: Scalars["String"];
};

/** How and where the attachment is used. */
export enum AttachmentKind {
  General = "GENERAL",
  UserAvatarImage = "USER_AVATAR_IMAGE",
  UserCoverImage = "USER_COVER_IMAGE",
  GroupCoverImage = "GROUP_COVER_IMAGE",
}

/** Kibela Web API budget like RateLimit of RESTful API */
export type Budget = {
  __typename?: "Budget";
  consumed: Scalars["BigInt"];
  /** The point cost for the current query counting against the budget. */
  cost: Scalars["BigInt"];
  remaining: Scalars["BigInt"];
};

/** Autogenerated input type of CloseAnnouncement */
export type CloseAnnouncementInput = {
  announcementKey: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CloseAnnouncement */
export type CloseAnnouncementPayload = {
  __typename?: "CloseAnnouncementPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** A comment that belongs to a Note */
export type Comment = Node & {
  __typename?: "Comment";
  anchor: Scalars["String"];
  author: User;
  canBeLiked: Scalars["Boolean"];
  canBeUpdated: Scalars["Boolean"];
  content: Scalars["String"];
  contentHtml: Scalars["String"];
  contentSummaryHtml: Scalars["String"];
  contentUpdatedAt: Scalars["DateTime"];
  contributors: UserConnection;
  createdAt: Scalars["DateTime"];
  editedAt?: Maybe<Scalars["DateTime"]>;
  id: Scalars["ID"];
  isEdited: Scalars["Boolean"];
  isLikedByCurrentUser: Scalars["Boolean"];
  likers: UserConnection;
  path: Scalars["String"];
  publishedAt?: Maybe<Scalars["DateTime"]>;
  replies: CommentReplyConnection;
  updatedAt: Scalars["DateTime"];
};

/** A comment that belongs to a Note */
export type CommentContributorsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  orderBy?: Maybe<ContributorOrder>;
};

/** A comment that belongs to a Note */
export type CommentLikersArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** A comment that belongs to a Note */
export type CommentRepliesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The connection type for Comment. */
export type CommentConnection = {
  __typename?: "CommentConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Comment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type CommentEdge = {
  __typename?: "CommentEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<Comment>;
};

/** The Comment Reply type */
export type CommentReply = Node & {
  __typename?: "CommentReply";
  anchor: Scalars["String"];
  author: User;
  canBeLiked: Scalars["Boolean"];
  canBeUpdated: Scalars["Boolean"];
  content: Scalars["String"];
  contentHtml: Scalars["String"];
  contentSummaryHtml: Scalars["String"];
  contentUpdatedAt: Scalars["DateTime"];
  contributors: UserConnection;
  createdAt: Scalars["DateTime"];
  editedAt?: Maybe<Scalars["DateTime"]>;
  id: Scalars["ID"];
  isEdited: Scalars["Boolean"];
  isLikedByCurrentUser: Scalars["Boolean"];
  likers: UserConnection;
  path: Scalars["String"];
  publishedAt?: Maybe<Scalars["DateTime"]>;
  updatedAt: Scalars["DateTime"];
};

/** The Comment Reply type */
export type CommentReplyContributorsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  orderBy?: Maybe<ContributorOrder>;
};

/** The Comment Reply type */
export type CommentReplyLikersArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The connection type for CommentReply. */
export type CommentReplyConnection = {
  __typename?: "CommentReplyConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommentReplyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CommentReply>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type CommentReplyEdge = {
  __typename?: "CommentReplyEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<CommentReply>;
};

export type ContributorOrder = {
  field?: Maybe<ContributorOrderField>;
  direction?: Maybe<OrderDirection>;
};

/** Properties by which contributors can be ordered. */
export enum ContributorOrderField {
  ContributedAt = "CONTRIBUTED_AT",
}

/** Autogenerated input type of CreateAccessToken */
export type CreateAccessTokenInput = {
  title: Scalars["String"];
  description: Scalars["String"];
  scopes: Array<AccessTokenScope>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateAccessToken */
export type CreateAccessTokenPayload = {
  __typename?: "CreateAccessTokenPayload";
  /** It includes the secret `token`, which you never see again. */
  accessToken: AccessToken;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of CreateComment */
export type CreateCommentInput = {
  commentableId: Scalars["ID"];
  content: Scalars["String"];
  /**
   * You can set any user as the author.
   * The default is the user who executes this mutation.
   * Note that the contributors still include the user who executes this mutation in order to avoid spoofing.
   */
  authorId?: Maybe<Scalars["ID"]>;
  /** The time when the comment is published. If not specified, `createdAt` is set to `publishedAt` */
  publishedAt?: Maybe<Scalars["DateTime"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateComment */
export type CreateCommentPayload = {
  __typename?: "CreateCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  comment: Comment;
};

/** Autogenerated input type of CreateCommentReply */
export type CreateCommentReplyInput = {
  commentId: Scalars["ID"];
  content: Scalars["String"];
  /**
   * You can set any user as the author.
   * The default is the user who executes this mutation.
   * Note that the contributors still include the user who executes this mutation in order to avoid spoofing.
   */
  authorId?: Maybe<Scalars["ID"]>;
  /** The time when the comment is published. If not specified, `createdAt` is set to `publishedAt` */
  publishedAt?: Maybe<Scalars["DateTime"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateCommentReply */
export type CreateCommentReplyPayload = {
  __typename?: "CreateCommentReplyPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  reply: CommentReply;
};

/** Autogenerated input type of CreateCustomEmoji */
export type CreateCustomEmojiInput = {
  /** Up to 50 alphanumeric characters and underscores(_) can be used. */
  emojiCode: Scalars["String"];
  /** BASE64 encoded image data URL */
  imageDataUrl: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateCustomEmoji */
export type CreateCustomEmojiPayload = {
  __typename?: "CreateCustomEmojiPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  customEmoji: CustomEmoji;
};

/** Autogenerated input type of CreateDisabledUser */
export type CreateDisabledUserInput = {
  /** `account` must be unique in the team */
  account: Scalars["String"];
  /** `email` must be unique in the team */
  email: Scalars["String"];
  realName: Scalars["String"];
  role?: Maybe<Role>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateDisabledUser */
export type CreateDisabledUserPayload = {
  __typename?: "CreateDisabledUserPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  user: User;
};

/** Autogenerated input type of CreateFolder */
export type CreateFolderInput = {
  folderName: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateFolder */
export type CreateFolderPayload = {
  __typename?: "CreateFolderPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  folder: Folder;
};

/** Autogenerated input type of CreateFolderPin */
export type CreateFolderPinInput = {
  noteId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateFolderPin */
export type CreateFolderPinPayload = {
  __typename?: "CreateFolderPinPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  folder: Folder;
};

/** Autogenerated input type of CreateGroup */
export type CreateGroupInput = {
  name: Scalars["String"];
  description: Scalars["String"];
  isPrivate: Scalars["Boolean"];
  coverImageKey?: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateGroup */
export type CreateGroupPayload = {
  __typename?: "CreateGroupPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  group: Group;
};

/** Autogenerated input type of CreateGroupPin */
export type CreateGroupPinInput = {
  groupId: Scalars["ID"];
  noteId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateGroupPin */
export type CreateGroupPinPayload = {
  __typename?: "CreateGroupPinPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  group: Group;
};

/** Autogenerated input type of CreateNote */
export type CreateNoteInput = {
  title: Scalars["String"];
  content: Scalars["String"];
  draft?: Maybe<Scalars["Boolean"]>;
  coediting: Scalars["Boolean"];
  groupIds: Array<Scalars["ID"]>;
  folderName?: Maybe<Scalars["String"]>;
  /**
   * You can set any user as the author.
   * The default is the user who executes this mutation.
   * Note that the contributors still include the user who executes this mutation in order to avoid spoofing.
   */
  authorId?: Maybe<Scalars["ID"]>;
  /** The time when the note is published. If `draft: true` is specified, the param is ignored. */
  publishedAt?: Maybe<Scalars["DateTime"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateNote */
export type CreateNotePayload = {
  __typename?: "CreateNotePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  note: Note;
};

/** Autogenerated input type of CreateNoteTemplate */
export type CreateNoteTemplateInput = {
  name: Scalars["String"];
  title: Scalars["String"];
  content: Scalars["String"];
  groupIds: Array<Scalars["ID"]>;
  folderFullName?: Maybe<Scalars["String"]>;
  coediting: Scalars["Boolean"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateNoteTemplate */
export type CreateNoteTemplatePayload = {
  __typename?: "CreateNoteTemplatePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  noteTemplate: NoteTemplate;
};

/** Autogenerated input type of CreateReviewableDraftComment */
export type CreateReviewableDraftCommentInput = {
  reviewableDraftId: Scalars["ID"];
  content: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateReviewableDraftComment */
export type CreateReviewableDraftCommentPayload = {
  __typename?: "CreateReviewableDraftCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  comment: ReviewableDraftComment;
};

/** The Custom Emoji type */
export type CustomEmoji = Node & {
  __typename?: "CustomEmoji";
  createUser: User;
  createdAt: Scalars["DateTime"];
  emojiCode: Scalars["String"];
  id: Scalars["ID"];
  imageUrl: Scalars["String"];
  updatedAt: Scalars["DateTime"];
};

/** The connection type for CustomEmoji. */
export type CustomEmojiConnection = {
  __typename?: "CustomEmojiConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomEmojiEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomEmoji>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type CustomEmojiEdge = {
  __typename?: "CustomEmojiEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<CustomEmoji>;
};

/** A dashboard of a group */
export type Dashboard = Node & {
  __typename?: "Dashboard";
  content: Scalars["String"];
  contentHtml: Scalars["String"];
  createdAt: Scalars["DateTime"];
  group: Group;
  id: Scalars["ID"];
  updatedAt: Scalars["DateTime"];
};

/** Autogenerated input type of DeleteAttachment */
export type DeleteAttachmentInput = {
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of DeleteAttachment */
export type DeleteAttachmentPayload = {
  __typename?: "DeleteAttachmentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of DeleteComment */
export type DeleteCommentInput = {
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of DeleteComment */
export type DeleteCommentPayload = {
  __typename?: "DeleteCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of DeleteCommentReply */
export type DeleteCommentReplyInput = {
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of DeleteCommentReply */
export type DeleteCommentReplyPayload = {
  __typename?: "DeleteCommentReplyPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of DeleteCustomEmoji */
export type DeleteCustomEmojiInput = {
  customEmojiId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of DeleteCustomEmoji */
export type DeleteCustomEmojiPayload = {
  __typename?: "DeleteCustomEmojiPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of DeleteGroup */
export type DeleteGroupInput = {
  id: Scalars["ID"];
  mergeToId?: Maybe<Scalars["ID"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of DeleteGroup */
export type DeleteGroupPayload = {
  __typename?: "DeleteGroupPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of DeleteNote */
export type DeleteNoteInput = {
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of DeleteNote */
export type DeleteNotePayload = {
  __typename?: "DeleteNotePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of DisableDraftReview */
export type DisableDraftReviewInput = {
  noteId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of DisableDraftReview */
export type DisableDraftReviewPayload = {
  __typename?: "DisableDraftReviewPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  reviewableDraft: ReviewableDraft;
};

/** Autogenerated input type of DisableOutgoingWebhook */
export type DisableOutgoingWebhookInput = {
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of DisableOutgoingWebhook */
export type DisableOutgoingWebhookPayload = {
  __typename?: "DisableOutgoingWebhookPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  outgoingWebhook: OutgoingWebhook;
};

/** Autogenerated input type of DisableSharedEntry */
export type DisableSharedEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of DisableSharedEntry */
export type DisableSharedEntryPayload = {
  __typename?: "DisableSharedEntryPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of DisableUser */
export type DisableUserInput = {
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of DisableUser */
export type DisableUserPayload = {
  __typename?: "DisableUserPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of EnableDraftReview */
export type EnableDraftReviewInput = {
  noteId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of EnableDraftReview */
export type EnableDraftReviewPayload = {
  __typename?: "EnableDraftReviewPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  reviewableDraft: ReviewableDraft;
};

/** Autogenerated input type of EnableOutgoingWebhook */
export type EnableOutgoingWebhookInput = {
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of EnableOutgoingWebhook */
export type EnableOutgoingWebhookPayload = {
  __typename?: "EnableOutgoingWebhookPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  outgoingWebhook: OutgoingWebhook;
};

/** Autogenerated input type of EnableSharedEntry */
export type EnableSharedEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of EnableSharedEntry */
export type EnableSharedEntryPayload = {
  __typename?: "EnableSharedEntryPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** A section of a feed, which includes notes in a folder */
export type FeedFolderParcel = {
  __typename?: "FeedFolderParcel";
  date: Scalars["DateTime"];
  folder: Folder;
  notes: NoteConnection;
};

/** A section of a feed, which includes notes in a folder */
export type FeedFolderParcelNotesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The kind to indicate what the feed is */
export enum FeedKind {
  Group = "GROUP",
  MyFeed = "MY_FEED",
  All = "ALL",
}

/** A section of feed, which includes a note */
export type FeedNote = {
  __typename?: "FeedNote";
  date: Scalars["DateTime"];
  note: Note;
};

/** A section of feed, which includes one or more notes */
export type FeedSection = FeedFolderParcel | FeedNote | FeedUserParcel;

export type FeedSectionSimpleConnection = {
  __typename?: "FeedSectionSimpleConnection";
  edges: Array<FeedSectionSimpleEdge>;
  pageInfo: FeedSectionSimplePageInfo;
};

export type FeedSectionSimpleEdge = {
  __typename?: "FeedSectionSimpleEdge";
  node: FeedSection;
};

export type FeedSectionSimplePageInfo = {
  __typename?: "FeedSectionSimplePageInfo";
  endCursor: Scalars["String"];
};

/** A section of feed, which includes notes written by a user */
export type FeedUserParcel = {
  __typename?: "FeedUserParcel";
  date: Scalars["DateTime"];
  notes: NoteConnection;
  user: User;
};

/** A section of feed, which includes notes written by a user */
export type FeedUserParcelNotesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type Folder = Node & {
  __typename?: "Folder";
  archivedAt?: Maybe<Scalars["DateTime"]>;
  components: Array<Folder>;
  createdAt: Scalars["DateTime"];
  folders: FolderConnection;
  fullName: Scalars["String"];
  id: Scalars["ID"];
  lastModifiedAt?: Maybe<Scalars["DateTime"]>;
  name: Scalars["String"];
  newNotePath: Scalars["String"];
  notes: NoteConnection;
  path: Scalars["String"];
  pinnedNotes: NoteConnection;
  updatedAt: Scalars["DateTime"];
};

export type FolderFoldersArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  active?: Maybe<Scalars["Boolean"]>;
};

export type FolderNotesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  onlyCoediting?: Maybe<Scalars["Boolean"]>;
  orderBy?: Maybe<NoteOrder>;
};

export type FolderPinnedNotesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The connection type for Folder. */
export type FolderConnection = {
  __typename?: "FolderConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<FolderEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Folder>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type FolderEdge = {
  __typename?: "FolderEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<Folder>;
};

export type Group = Node & {
  __typename?: "Group";
  archivedAt?: Maybe<Scalars["DateTime"]>;
  /** @deprecated deleteGroup will be removed. Use archiveGroup instead. */
  canBeDestroyed: Scalars["Boolean"];
  canBeManaged: Scalars["Boolean"];
  coverImage: GroupCoverImage;
  coverImageKey?: Maybe<Scalars["String"]>;
  createdAt: Scalars["DateTime"];
  /** @deprecated Provided only for legacy frontend. */
  databaseId: Scalars["Int"];
  description: Scalars["String"];
  /** @deprecated Use query.feedSections instead */
  feedSections: FeedSectionSimpleConnection;
  feedUpdatedAt?: Maybe<Scalars["DateTime"]>;
  id: Scalars["ID"];
  isArchived: Scalars["Boolean"];
  isDefault: Scalars["Boolean"];
  isJoined: Scalars["Boolean"];
  isPrivate: Scalars["Boolean"];
  name: Scalars["String"];
  notes: NoteConnection;
  path: Scalars["String"];
  pinnedNotes: Array<Note>;
  todayContributors: UserConnection;
  trendNotes: NoteConnection;
  updatedAt: Scalars["DateTime"];
  users: UserConnection;
};

export type GroupCoverImageArgs = {
  size: GroupCoverImageSize;
  density: Scalars["Int"];
};

export type GroupFeedSectionsArgs = {
  first?: Maybe<Scalars["Int"]>;
  after?: Maybe<Scalars["String"]>;
};

export type GroupNotesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  orderBy?: Maybe<NoteOrder>;
};

export type GroupTodayContributorsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type GroupTrendNotesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type GroupUsersArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The connection type for Group. */
export type GroupConnection = {
  __typename?: "GroupConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Group>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** Cover image of a group */
export type GroupCoverImage = {
  __typename?: "GroupCoverImage";
  density: Scalars["Int"];
  height: Scalars["Int"];
  url: Scalars["String"];
  width: Scalars["Int"];
};

/** The size class of group cover images */
export enum GroupCoverImageSize {
  Medium = "MEDIUM",
  Large = "LARGE",
}

/** An edge in a connection. */
export type GroupEdge = {
  __typename?: "GroupEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<Group>;
};

/** Autogenerated input type of IgnoreMultiFactorAuthn */
export type IgnoreMultiFactorAuthnInput = {
  userId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of IgnoreMultiFactorAuthn */
export type IgnoreMultiFactorAuthnPayload = {
  __typename?: "IgnoreMultiFactorAuthnPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** A user representation from importable services */
export type ImportableUser = {
  __typename?: "ImportableUser";
  account: Scalars["String"];
  avatarUrl: Scalars["String"];
  realName: Scalars["String"];
};

/** The connection type for ImportableUser. */
export type ImportableUserConnection = {
  __typename?: "ImportableUserConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ImportableUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ImportableUser>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type ImportableUserEdge = {
  __typename?: "ImportableUserEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<ImportableUser>;
};

/** Message hints that suggest what happens in sending invitations */
export enum InvitationHint {
  /** The invitation has been sent to them. */
  Invited = "INVITED",
  /** Those who is disabled before is now re-enabled. Nothing is done. */
  ReEnabled = "RE_ENABLED",
  /** They is already a member of the team. Nothing is done. */
  AlreadyJoined = "ALREADY_JOINED",
}

/** Autogenerated input type of Invite */
export type InviteInput = {
  email: Scalars["String"];
  role?: Maybe<Role>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of Invite */
export type InvitePayload = {
  __typename?: "InvitePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  email: Scalars["String"];
  hint: InvitationHint;
  role: Role;
};

/** Autogenerated input type of JoinGroup */
export type JoinGroupInput = {
  groupId: Scalars["ID"];
  userId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of JoinGroup */
export type JoinGroupPayload = {
  __typename?: "JoinGroupPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of LeaveGroup */
export type LeaveGroupInput = {
  groupId: Scalars["ID"];
  userId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of LeaveGroup */
export type LeaveGroupPayload = {
  __typename?: "LeaveGroupPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of Like */
export type LikeInput = {
  likableId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of Like */
export type LikePayload = {
  __typename?: "LikePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  likers: UserConnection;
};

/** Autogenerated return type of Like */
export type LikePayloadLikersArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** Autogenerated input type of MarkNotificationsAsRead */
export type MarkNotificationsAsReadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of MarkNotificationsAsRead */
export type MarkNotificationsAsReadPayload = {
  __typename?: "MarkNotificationsAsReadPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** The top-level mutation type to mutate resources */
export type Mutation = {
  __typename?: "Mutation";
  /** Archive a folder */
  archiveFolder?: Maybe<ArchiveFolderPayload>;
  /** Archive a group */
  archiveGroup?: Maybe<ArchiveGroupPayload>;
  /** Archive a note */
  archiveNote?: Maybe<ArchiveNotePayload>;
  /** Close an announcement */
  closeAnnouncement?: Maybe<CloseAnnouncementPayload>;
  /** It creates an access token */
  createAccessToken?: Maybe<CreateAccessTokenPayload>;
  /** Creates a comment */
  createComment?: Maybe<CreateCommentPayload>;
  /** Creates a reply to the comment */
  createCommentReply?: Maybe<CreateCommentReplyPayload>;
  /** Creates a custom emoji */
  createCustomEmoji?: Maybe<CreateCustomEmojiPayload>;
  /** It creates a disabled user with the specified profile. It requires  **administrative privileges**. */
  createDisabledUser?: Maybe<CreateDisabledUserPayload>;
  /** Creates a folder */
  createFolder?: Maybe<CreateFolderPayload>;
  /** Pin note to a folder */
  createFolderPin?: Maybe<CreateFolderPinPayload>;
  /**
   * Creates a group. The current user is added as a group member.
   *
   * It may fail with the `UPGRADE_REQUIRED` error code if the plan is free and there is no room to create a new group.
   */
  createGroup?: Maybe<CreateGroupPayload>;
  /** Pin note to a group */
  createGroupPin?: Maybe<CreateGroupPinPayload>;
  /** Creates a note */
  createNote?: Maybe<CreateNotePayload>;
  /** Create a note template */
  createNoteTemplate?: Maybe<CreateNoteTemplatePayload>;
  /** Creates a draft review comment */
  createReviewableDraftComment?: Maybe<CreateReviewableDraftCommentPayload>;
  /** It deletes an attachment that is owned by the current user. */
  deleteAttachment?: Maybe<DeleteAttachmentPayload>;
  /** Deletes a comment */
  deleteComment?: Maybe<DeleteCommentPayload>;
  /** Deletes a reply to comment */
  deleteCommentReply?: Maybe<DeleteCommentReplyPayload>;
  /** Deletes a custom emoji */
  deleteCustomEmoji?: Maybe<DeleteCustomEmojiPayload>;
  /**
   * Delete a group
   * @deprecated This feature will be deleted. Use archiveGroup mutation instead.
   */
  deleteGroup?: Maybe<DeleteGroupPayload>;
  /** Deletes a note */
  deleteNote?: Maybe<DeleteNotePayload>;
  /** Disable draft review of the specified note. */
  disableDraftReview?: Maybe<DisableDraftReviewPayload>;
  /** Disable Outgoing Webhook */
  disableOutgoingWebhook?: Maybe<DisableOutgoingWebhookPayload>;
  /** Disable shared entry setting */
  disableSharedEntry?: Maybe<DisableSharedEntryPayload>;
  /** Disables a user. The current user must be an *admin* or *owner*. */
  disableUser?: Maybe<DisableUserPayload>;
  /** Enable draft review of the specified note. */
  enableDraftReview?: Maybe<EnableDraftReviewPayload>;
  /** Enable Outgoing Webhook */
  enableOutgoingWebhook?: Maybe<EnableOutgoingWebhookPayload>;
  /** Enable shared entry setting */
  enableSharedEntry?: Maybe<EnableSharedEntryPayload>;
  /** Ignore multi factor authn for 1 day. */
  ignoreMultiFactorAuthn?: Maybe<IgnoreMultiFactorAuthnPayload>;
  /**
   * Invites a user with their email.
   * Only owners and admins can invite users.
   *
   * It may fail with the `UPGRADE_REQUIRED` error code if the plan is free and there is no room to create a new user.
   */
  invite?: Maybe<InvitePayload>;
  /** Join a group */
  joinGroup?: Maybe<JoinGroupPayload>;
  /** Leave a group */
  leaveGroup?: Maybe<LeaveGroupPayload>;
  /** Like a note or comment */
  like?: Maybe<LikePayload>;
  markNotificationsAsRead?: Maybe<MarkNotificationsAsReadPayload>;
  /** Remove pinned note from a folder */
  removeFolderPin?: Maybe<RemoveFolderPinPayload>;
  /** Remove pinned note from a group */
  removeGroupPin?: Maybe<RemoveGroupPinPayload>;
  /** Restore an archived folder */
  restoreFolder?: Maybe<RestoreFolderPayload>;
  /** Restore an archived group */
  restoreGroup?: Maybe<RestoreGroupPayload>;
  /** Restore an archived note */
  restoreNote?: Maybe<RestoreNotePayload>;
  /** It revokes an access token; the secret `token` is available after the access token is revoked. */
  revokeAccessToken?: Maybe<RevokeAccessTokenPayload>;
  /** Transfer notes of a group to another */
  transferGroupNotes?: Maybe<TransferGroupNotesPayload>;
  /** Unlike a note or comment */
  unlike?: Maybe<UnlikePayload>;
  /** Unwatch a note */
  unwatchNote?: Maybe<UnwatchNotePayload>;
  /** It updates attributes of an access token */
  updateAccessToken?: Maybe<UpdateAccessTokenPayload>;
  /** Updates a comment */
  updateComment?: Maybe<UpdateCommentPayload>;
  /** Updates a reply to comment */
  updateCommentReply?: Maybe<UpdateCommentReplyPayload>;
  /** Update the content of dashboard without conflict-checking. Use updateDashboardContent to check conflict. */
  updateDashboard?: Maybe<UpdateDashboardPayload>;
  /** Update the content of a dashboard with simple conflict-checking */
  updateDashboardContent?: Maybe<UpdateDashboardContentPayload>;
  /** Update name of a folder */
  updateFolderName?: Maybe<UpdateFolderNamePayload>;
  /** Update the folder parent */
  updateFolderParent?: Maybe<UpdateFolderParentPayload>;
  /** Update a group */
  updateGroup?: Maybe<UpdateGroupPayload>;
  /** Update a note, trying to merge conflicts with the 3-way diff algorithm */
  updateNote?: Maybe<UpdateNotePayload>;
  /** Update the content of a note with conflict-checking, trying 3-way merging on conflicts */
  updateNoteContent?: Maybe<UpdateNoteContentPayload>;
  /** Update the folder associated to a note */
  updateNoteFolder?: Maybe<UpdateNoteFolderPayload>;
  /** Update a note template */
  updateNoteTemplate?: Maybe<UpdateNoteTemplatePayload>;
  /** Update title of a note */
  updateNoteTitle?: Maybe<UpdateNoteTitlePayload>;
  /** Update team setting */
  updateTeamSetting?: Maybe<UpdateTeamSettingPayload>;
  /** Update notification setting of current user */
  updateUserNotificationSetting?: Maybe<UpdateUserNotificationSettingPayload>;
  /** Upload an attachment as files in markdown contents, avatars, or cover images. */
  uploadAttachment?: Maybe<UploadAttachmentPayload>;
  /** Upload an attachment as files in markdown contents, avatars, or cover images. */
  uploadAttachmentWithDataUrl?: Maybe<UploadAttachmentWithDataUrlPayload>;
  /** Watch a note */
  watchNote?: Maybe<WatchNotePayload>;
};

/** The top-level mutation type to mutate resources */
export type MutationArchiveFolderArgs = {
  input: ArchiveFolderInput;
};

/** The top-level mutation type to mutate resources */
export type MutationArchiveGroupArgs = {
  input: ArchiveGroupInput;
};

/** The top-level mutation type to mutate resources */
export type MutationArchiveNoteArgs = {
  input: ArchiveNoteInput;
};

/** The top-level mutation type to mutate resources */
export type MutationCloseAnnouncementArgs = {
  input: CloseAnnouncementInput;
};

/** The top-level mutation type to mutate resources */
export type MutationCreateAccessTokenArgs = {
  input: CreateAccessTokenInput;
};

/** The top-level mutation type to mutate resources */
export type MutationCreateCommentArgs = {
  input: CreateCommentInput;
};

/** The top-level mutation type to mutate resources */
export type MutationCreateCommentReplyArgs = {
  input: CreateCommentReplyInput;
};

/** The top-level mutation type to mutate resources */
export type MutationCreateCustomEmojiArgs = {
  input: CreateCustomEmojiInput;
};

/** The top-level mutation type to mutate resources */
export type MutationCreateDisabledUserArgs = {
  input: CreateDisabledUserInput;
};

/** The top-level mutation type to mutate resources */
export type MutationCreateFolderArgs = {
  input: CreateFolderInput;
};

/** The top-level mutation type to mutate resources */
export type MutationCreateFolderPinArgs = {
  input: CreateFolderPinInput;
};

/** The top-level mutation type to mutate resources */
export type MutationCreateGroupArgs = {
  input: CreateGroupInput;
};

/** The top-level mutation type to mutate resources */
export type MutationCreateGroupPinArgs = {
  input: CreateGroupPinInput;
};

/** The top-level mutation type to mutate resources */
export type MutationCreateNoteArgs = {
  input: CreateNoteInput;
};

/** The top-level mutation type to mutate resources */
export type MutationCreateNoteTemplateArgs = {
  input: CreateNoteTemplateInput;
};

/** The top-level mutation type to mutate resources */
export type MutationCreateReviewableDraftCommentArgs = {
  input: CreateReviewableDraftCommentInput;
};

/** The top-level mutation type to mutate resources */
export type MutationDeleteAttachmentArgs = {
  input: DeleteAttachmentInput;
};

/** The top-level mutation type to mutate resources */
export type MutationDeleteCommentArgs = {
  input: DeleteCommentInput;
};

/** The top-level mutation type to mutate resources */
export type MutationDeleteCommentReplyArgs = {
  input: DeleteCommentReplyInput;
};

/** The top-level mutation type to mutate resources */
export type MutationDeleteCustomEmojiArgs = {
  input: DeleteCustomEmojiInput;
};

/** The top-level mutation type to mutate resources */
export type MutationDeleteGroupArgs = {
  input: DeleteGroupInput;
};

/** The top-level mutation type to mutate resources */
export type MutationDeleteNoteArgs = {
  input: DeleteNoteInput;
};

/** The top-level mutation type to mutate resources */
export type MutationDisableDraftReviewArgs = {
  input: DisableDraftReviewInput;
};

/** The top-level mutation type to mutate resources */
export type MutationDisableOutgoingWebhookArgs = {
  input: DisableOutgoingWebhookInput;
};

/** The top-level mutation type to mutate resources */
export type MutationDisableSharedEntryArgs = {
  input: DisableSharedEntryInput;
};

/** The top-level mutation type to mutate resources */
export type MutationDisableUserArgs = {
  input: DisableUserInput;
};

/** The top-level mutation type to mutate resources */
export type MutationEnableDraftReviewArgs = {
  input: EnableDraftReviewInput;
};

/** The top-level mutation type to mutate resources */
export type MutationEnableOutgoingWebhookArgs = {
  input: EnableOutgoingWebhookInput;
};

/** The top-level mutation type to mutate resources */
export type MutationEnableSharedEntryArgs = {
  input: EnableSharedEntryInput;
};

/** The top-level mutation type to mutate resources */
export type MutationIgnoreMultiFactorAuthnArgs = {
  input: IgnoreMultiFactorAuthnInput;
};

/** The top-level mutation type to mutate resources */
export type MutationInviteArgs = {
  input: InviteInput;
};

/** The top-level mutation type to mutate resources */
export type MutationJoinGroupArgs = {
  input: JoinGroupInput;
};

/** The top-level mutation type to mutate resources */
export type MutationLeaveGroupArgs = {
  input: LeaveGroupInput;
};

/** The top-level mutation type to mutate resources */
export type MutationLikeArgs = {
  input: LikeInput;
};

/** The top-level mutation type to mutate resources */
export type MutationMarkNotificationsAsReadArgs = {
  input: MarkNotificationsAsReadInput;
};

/** The top-level mutation type to mutate resources */
export type MutationRemoveFolderPinArgs = {
  input: RemoveFolderPinInput;
};

/** The top-level mutation type to mutate resources */
export type MutationRemoveGroupPinArgs = {
  input: RemoveGroupPinInput;
};

/** The top-level mutation type to mutate resources */
export type MutationRestoreFolderArgs = {
  input: RestoreFolderInput;
};

/** The top-level mutation type to mutate resources */
export type MutationRestoreGroupArgs = {
  input: RestoreGroupInput;
};

/** The top-level mutation type to mutate resources */
export type MutationRestoreNoteArgs = {
  input: RestoreNoteInput;
};

/** The top-level mutation type to mutate resources */
export type MutationRevokeAccessTokenArgs = {
  input: RevokeAccessTokenInput;
};

/** The top-level mutation type to mutate resources */
export type MutationTransferGroupNotesArgs = {
  input: TransferGroupNotesInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUnlikeArgs = {
  input: UnlikeInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUnwatchNoteArgs = {
  input: UnwatchNoteInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateAccessTokenArgs = {
  input: UpdateAccessTokenInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateCommentArgs = {
  input: UpdateCommentInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateCommentReplyArgs = {
  input: UpdateCommentReplyInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateDashboardArgs = {
  input: UpdateDashboardInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateDashboardContentArgs = {
  input: UpdateDashboardContentInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateFolderNameArgs = {
  input: UpdateFolderNameInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateFolderParentArgs = {
  input: UpdateFolderParentInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateGroupArgs = {
  input: UpdateGroupInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteArgs = {
  input: UpdateNoteInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteContentArgs = {
  input: UpdateNoteContentInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteFolderArgs = {
  input: UpdateNoteFolderInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteTemplateArgs = {
  input: UpdateNoteTemplateInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteTitleArgs = {
  input: UpdateNoteTitleInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateTeamSettingArgs = {
  input: UpdateTeamSettingInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUpdateUserNotificationSettingArgs = {
  input: UpdateUserNotificationSettingInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUploadAttachmentArgs = {
  input: UploadAttachmentInput;
};

/** The top-level mutation type to mutate resources */
export type MutationUploadAttachmentWithDataUrlArgs = {
  input: UploadAttachmentWithDataUrlInput;
};

/** The top-level mutation type to mutate resources */
export type MutationWatchNoteArgs = {
  input: WatchNoteInput;
};

/** An object with an ID. */
export type Node = {
  /** ID of the object. */
  id: Scalars["ID"];
};

/** The Note type */
export type Note = Node & {
  __typename?: "Note";
  author?: Maybe<User>;
  canBeCommented: Scalars["Boolean"];
  canBeDestroyed: Scalars["Boolean"];
  canBeLiked: Scalars["Boolean"];
  canBeUpdated: Scalars["Boolean"];
  coediting: Scalars["Boolean"];
  comments: CommentConnection;
  commentsCount: Scalars["Int"];
  content: Scalars["String"];
  contentHtml: Scalars["String"];
  contentSummaryHtml: Scalars["String"];
  contentTocHtml: Scalars["String"];
  contentUpdatedAt: Scalars["DateTime"];
  contributors: UserConnection;
  createdAt: Scalars["DateTime"];
  /** @deprecated Provided only for legacy frontend. */
  databaseId: Scalars["Int"];
  editPath: Scalars["String"];
  folder?: Maybe<Folder>;
  folderName?: Maybe<Scalars["String"]>;
  groups: Array<Group>;
  id: Scalars["ID"];
  isArchived: Scalars["Boolean"];
  isLikedByCurrentUser: Scalars["Boolean"];
  likers: UserConnection;
  path: Scalars["String"];
  publishedAt?: Maybe<Scalars["DateTime"]>;
  relatedNotes: SearchResultConnection;
  reviewableDraft?: Maybe<ReviewableDraft>;
  title: Scalars["String"];
  /** @deprecated There is ExtendedText component in js, so almost unnecessary to use it */
  titleHtml: Scalars["String"];
  trackbackNotes: NoteConnection;
  updatedAt: Scalars["DateTime"];
  url: Scalars["String"];
};

/** The Note type */
export type NoteCommentsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The Note type */
export type NoteContributorsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  orderBy?: Maybe<ContributorOrder>;
};

/** The Note type */
export type NoteLikersArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The Note type */
export type NoteRelatedNotesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The Note type */
export type NoteTrackbackNotesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** Browsing history of notes */
export type NoteBrowsingHistory = Node & {
  __typename?: "NoteBrowsingHistory";
  id: Scalars["ID"];
  note?: Maybe<Note>;
};

/** The connection type for NoteBrowsingHistory. */
export type NoteBrowsingHistoryConnection = {
  __typename?: "NoteBrowsingHistoryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteBrowsingHistoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<NoteBrowsingHistory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type NoteBrowsingHistoryEdge = {
  __typename?: "NoteBrowsingHistoryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<NoteBrowsingHistory>;
};

/** The connection type for Note. */
export type NoteConnection = {
  __typename?: "NoteConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Note>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type NoteEdge = {
  __typename?: "NoteEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<Note>;
};

/** Note input struct, used to updateNote mutation */
export type NoteInput = {
  title: Scalars["String"];
  content: Scalars["String"];
  groupIds: Array<Scalars["ID"]>;
  folderName?: Maybe<Scalars["String"]>;
  coediting: Scalars["Boolean"];
};

export type NoteOrder = {
  field?: Maybe<NoteOrderField>;
  direction?: Maybe<OrderDirection>;
};

/** Properties by which notes can be ordered. */
export enum NoteOrderField {
  ContentUpdatedAt = "CONTENT_UPDATED_AT",
  Title = "TITLE",
  PublishedAt = "PUBLISHED_AT",
}

/** Template of note */
export type NoteTemplate = Node & {
  __typename?: "NoteTemplate";
  content: Scalars["String"];
  createdAt: Scalars["DateTime"];
  evaluatedTitle: Scalars["String"];
  folderEvaluatedFullName?: Maybe<Scalars["String"]>;
  folderFullName?: Maybe<Scalars["String"]>;
  groups: Array<Group>;
  id: Scalars["ID"];
  name: Scalars["String"];
  title: Scalars["String"];
  updatedAt: Scalars["DateTime"];
};

/** The connection type for NoteTemplate. */
export type NoteTemplateConnection = {
  __typename?: "NoteTemplateConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteTemplateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<NoteTemplate>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type NoteTemplateEdge = {
  __typename?: "NoteTemplateEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<NoteTemplate>;
};

/** Notifications you get in a Kibela team */
export type Notification = Node & {
  __typename?: "Notification";
  createdAt: Scalars["DateTime"];
  id: Scalars["ID"];
  messageHtml: Scalars["String"];
  sender: User;
  sourcePath: Scalars["String"];
  state: NotificationState;
  updatedAt: Scalars["DateTime"];
};

/** The connection type for Notification. */
export type NotificationConnection = {
  __typename?: "NotificationConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NotificationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Notification>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type NotificationEdge = {
  __typename?: "NotificationEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<Notification>;
};

/** The state of notifications */
export enum NotificationState {
  Unread = "UNREAD",
  Read = "READ",
}

export enum OrderDirection {
  Asc = "ASC",
  Desc = "DESC",
}

/** Kind of the organization */
export enum OrganizationKind {
  Unknown = "UNKNOWN",
  Personal = "PERSONAL",
  Company = "COMPANY",
  Other = "OTHER",
}

/** A outgoing_webhook */
export type OutgoingWebhook = Node & {
  __typename?: "OutgoingWebhook";
  disabledAt?: Maybe<Scalars["DateTime"]>;
  id: Scalars["ID"];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: "PageInfo";
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars["String"]>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars["Boolean"];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars["Boolean"];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars["String"]>;
};

/** The top-level query type to Kibela resources */
export type Query = {
  __typename?: "Query";
  accessToken: AccessToken;
  accessTokens: AccessTokenConnection;
  /** The archived groups in the team including private ones */
  archivedGroups: GroupConnection;
  attachmentFromPath: Attachment;
  budget: Budget;
  comment?: Maybe<Comment>;
  /** The current user of the session */
  currentUser?: Maybe<User>;
  customEmojiFromCode: CustomEmoji;
  customEmojis: CustomEmojiConnection;
  defaultGroup?: Maybe<Group>;
  feedSections: FeedSectionSimpleConnection;
  folder?: Maybe<Folder>;
  folders: FolderConnection;
  group: Group;
  /** The active groups in the team including private ones */
  groups: GroupConnection;
  importableUsers: ImportableUserConnection;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Fetches a list of objects given a list of IDs. */
  nodes: Array<Maybe<Node>>;
  note?: Maybe<Note>;
  noteBrowsingHistries: NoteBrowsingHistoryConnection;
  noteFromPath: Note;
  noteTemplate?: Maybe<NoteTemplate>;
  noteTemplates: NoteTemplateConnection;
  /** The connection of all the notes in the team. You *should* specify `orderBy` in production. */
  notes: NoteConnection;
  notifications?: Maybe<NotificationConnection>;
  renderMarkdownToHtml: Scalars["String"];
  reviewableDraft?: Maybe<ReviewableDraft>;
  search: SearchResultConnection;
  /** All the access token logs in the team. This feature requires the administrative privileges */
  teamAccessTokenLogs: AccessTokenLogConnection;
  user?: Maybe<User>;
  userFromAccount?: Maybe<User>;
  users: UserConnection;
  validateToMove: Scalars["Boolean"];
};

/** The top-level query type to Kibela resources */
export type QueryAccessTokenArgs = {
  id: Scalars["ID"];
};

/** The top-level query type to Kibela resources */
export type QueryAccessTokensArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  revoked?: Maybe<Scalars["Boolean"]>;
};

/** The top-level query type to Kibela resources */
export type QueryArchivedGroupsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The top-level query type to Kibela resources */
export type QueryAttachmentFromPathArgs = {
  path: Scalars["String"];
};

/** The top-level query type to Kibela resources */
export type QueryCommentArgs = {
  id: Scalars["ID"];
};

/** The top-level query type to Kibela resources */
export type QueryCustomEmojiFromCodeArgs = {
  code: Scalars["String"];
};

/** The top-level query type to Kibela resources */
export type QueryCustomEmojisArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The top-level query type to Kibela resources */
export type QueryFeedSectionsArgs = {
  kind?: Maybe<FeedKind>;
  groupId?: Maybe<Scalars["ID"]>;
  first: Scalars["Int"];
  after?: Maybe<Scalars["String"]>;
};

/** The top-level query type to Kibela resources */
export type QueryFolderArgs = {
  id: Scalars["ID"];
};

/** The top-level query type to Kibela resources */
export type QueryFoldersArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  parentFolderId?: Maybe<Scalars["ID"]>;
  parentFolderIds?: Maybe<Array<Scalars["ID"]>>;
  active?: Maybe<Scalars["Boolean"]>;
};

/** The top-level query type to Kibela resources */
export type QueryGroupArgs = {
  id: Scalars["ID"];
};

/** The top-level query type to Kibela resources */
export type QueryGroupsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The top-level query type to Kibela resources */
export type QueryImportableUsersArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  serviceType: Scalars["String"];
  teamName: Scalars["String"];
  encryptedAccessToken: Scalars["String"];
  page: Scalars["Int"];
};

/** The top-level query type to Kibela resources */
export type QueryNodeArgs = {
  id: Scalars["ID"];
};

/** The top-level query type to Kibela resources */
export type QueryNodesArgs = {
  ids: Array<Scalars["ID"]>;
};

/** The top-level query type to Kibela resources */
export type QueryNoteArgs = {
  id: Scalars["ID"];
};

/** The top-level query type to Kibela resources */
export type QueryNoteBrowsingHistriesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The top-level query type to Kibela resources */
export type QueryNoteFromPathArgs = {
  path: Scalars["String"];
};

/** The top-level query type to Kibela resources */
export type QueryNoteTemplateArgs = {
  id: Scalars["ID"];
};

/** The top-level query type to Kibela resources */
export type QueryNoteTemplatesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The top-level query type to Kibela resources */
export type QueryNotesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  orderBy?: Maybe<NoteOrder>;
  folderId?: Maybe<Scalars["ID"]>;
  active?: Maybe<Scalars["Boolean"]>;
};

/** The top-level query type to Kibela resources */
export type QueryNotificationsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  state?: Maybe<NotificationState>;
};

/** The top-level query type to Kibela resources */
export type QueryRenderMarkdownToHtmlArgs = {
  content: Scalars["String"];
  isMain: Scalars["Boolean"];
};

/** The top-level query type to Kibela resources */
export type QueryReviewableDraftArgs = {
  id: Scalars["ID"];
};

/** The top-level query type to Kibela resources */
export type QuerySearchArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  query: Scalars["String"];
  coediting?: Maybe<Scalars["Boolean"]>;
  updated?: Maybe<SearchDate>;
  groupIds?: Maybe<Array<Scalars["ID"]>>;
  userIds?: Maybe<Array<Scalars["ID"]>>;
  folderIds?: Maybe<Array<Scalars["ID"]>>;
  isArchived?: Maybe<Scalars["Boolean"]>;
};

/** The top-level query type to Kibela resources */
export type QueryTeamAccessTokenLogsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The top-level query type to Kibela resources */
export type QueryUserArgs = {
  id: Scalars["ID"];
};

/** The top-level query type to Kibela resources */
export type QueryUserFromAccountArgs = {
  account: Scalars["String"];
};

/** The top-level query type to Kibela resources */
export type QueryUsersArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  query?: Maybe<Scalars["String"]>;
  confirmed?: Maybe<Scalars["Boolean"]>;
  enabled?: Maybe<Scalars["Boolean"]>;
  groupId?: Maybe<Scalars["ID"]>;
};

/** The top-level query type to Kibela resources */
export type QueryValidateToMoveArgs = {
  folderIds: Array<Scalars["ID"]>;
  noteIds: Array<Scalars["ID"]>;
  parentId?: Maybe<Scalars["ID"]>;
};

/** Autogenerated input type of RemoveFolderPin */
export type RemoveFolderPinInput = {
  noteId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of RemoveFolderPin */
export type RemoveFolderPinPayload = {
  __typename?: "RemoveFolderPinPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  folder: Folder;
};

/** Autogenerated input type of RemoveGroupPin */
export type RemoveGroupPinInput = {
  groupId: Scalars["ID"];
  noteId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of RemoveGroupPin */
export type RemoveGroupPinPayload = {
  __typename?: "RemoveGroupPinPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  group: Group;
};

/** Autogenerated input type of RestoreFolder */
export type RestoreFolderInput = {
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of RestoreFolder */
export type RestoreFolderPayload = {
  __typename?: "RestoreFolderPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  folder: Folder;
};

/** Autogenerated input type of RestoreGroup */
export type RestoreGroupInput = {
  groupId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of RestoreGroup */
export type RestoreGroupPayload = {
  __typename?: "RestoreGroupPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  group: Group;
};

/** Autogenerated input type of RestoreNote */
export type RestoreNoteInput = {
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of RestoreNote */
export type RestoreNotePayload = {
  __typename?: "RestoreNotePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  note: Note;
};

/** The Reviewable Draft type */
export type ReviewableDraft = {
  __typename?: "ReviewableDraft";
  comments: ReviewableDraftCommentConnection;
  id: Scalars["ID"];
  isEnabled: Scalars["Boolean"];
  url: Scalars["String"];
};

/** The Reviewable Draft type */
export type ReviewableDraftCommentsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** A comment that belongs to a reviewable drarft */
export type ReviewableDraftComment = Node & {
  __typename?: "ReviewableDraftComment";
  anchor: Scalars["String"];
  author: User;
  content: Scalars["String"];
  contentHtml: Scalars["String"];
  createdAt: Scalars["DateTime"];
  id: Scalars["ID"];
  path: Scalars["String"];
};

/** The connection type for ReviewableDraftComment. */
export type ReviewableDraftCommentConnection = {
  __typename?: "ReviewableDraftCommentConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReviewableDraftCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReviewableDraftComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type ReviewableDraftCommentEdge = {
  __typename?: "ReviewableDraftCommentEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<ReviewableDraftComment>;
};

/** Autogenerated input type of RevokeAccessToken */
export type RevokeAccessTokenInput = {
  /** AccessToken ID */
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of RevokeAccessToken */
export type RevokeAccessTokenPayload = {
  __typename?: "RevokeAccessTokenPayload";
  accessToken: AccessToken;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** A role of a user */
export enum Role {
  Owner = "OWNER",
  Admin = "ADMIN",
  FullMember = "FULL_MEMBER",
  Guest = "GUEST",
}

export enum SearchDate {
  Within_3Days = "WITHIN_3_DAYS",
  Within_1Week = "WITHIN_1_WEEK",
  Within_1Month = "WITHIN_1_MONTH",
  Within_6Months = "WITHIN_6_MONTHS",
}

/** A search result that refers to a document */
export type SearchResult = {
  __typename?: "SearchResult";
  author: User;
  contentSummaryHtml: Scalars["String"];
  contentUpdatedAt: Scalars["DateTime"];
  /** The original searchable document */
  document: SearchableDocument;
  folder?: Maybe<Folder>;
  path: Scalars["String"];
  title: Scalars["String"];
  titleHtml: Scalars["String"];
  url: Scalars["String"];
};

/** The connection type for SearchResult. */
export type SearchResultConnection = {
  __typename?: "SearchResultConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SearchResultEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SearchResult>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type SearchResultEdge = {
  __typename?: "SearchResultEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<SearchResult>;
};

export type SearchableDocument = Comment | CommentReply | Note;

/** Autogenerated input type of TransferGroupNotes */
export type TransferGroupNotesInput = {
  fromGroupId: Scalars["ID"];
  toGroupId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of TransferGroupNotes */
export type TransferGroupNotesPayload = {
  __typename?: "TransferGroupNotesPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  from: Group;
  to: Group;
};

/** Autogenerated input type of Unlike */
export type UnlikeInput = {
  likableId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of Unlike */
export type UnlikePayload = {
  __typename?: "UnlikePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  likers: UserConnection;
};

/** Autogenerated return type of Unlike */
export type UnlikePayloadLikersArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** Autogenerated input type of UnwatchNote */
export type UnwatchNoteInput = {
  noteId: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UnwatchNote */
export type UnwatchNotePayload = {
  __typename?: "UnwatchNotePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UpdateAccessToken */
export type UpdateAccessTokenInput = {
  id: Scalars["ID"];
  title: Scalars["String"];
  description: Scalars["String"];
  scopes: Array<AccessTokenScope>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateAccessToken */
export type UpdateAccessTokenPayload = {
  __typename?: "UpdateAccessTokenPayload";
  accessToken: AccessToken;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UpdateComment */
export type UpdateCommentInput = {
  id: Scalars["ID"];
  content: Scalars["String"];
  touch?: Maybe<Scalars["Boolean"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateComment */
export type UpdateCommentPayload = {
  __typename?: "UpdateCommentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  comment: Comment;
};

/** Autogenerated input type of UpdateCommentReply */
export type UpdateCommentReplyInput = {
  id: Scalars["ID"];
  content: Scalars["String"];
  touch?: Maybe<Scalars["Boolean"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateCommentReply */
export type UpdateCommentReplyPayload = {
  __typename?: "UpdateCommentReplyPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  reply: CommentReply;
};

/** Autogenerated input type of UpdateDashboardContent */
export type UpdateDashboardContentInput = {
  /** A group ID for the dashboard */
  groupId: Scalars["ID"];
  newContent: Scalars["String"];
  baseContent: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateDashboardContent */
export type UpdateDashboardContentPayload = {
  __typename?: "UpdateDashboardContentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  dashboard: Dashboard;
};

/** Autogenerated input type of UpdateDashboard */
export type UpdateDashboardInput = {
  groupId: Scalars["ID"];
  content: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateDashboard */
export type UpdateDashboardPayload = {
  __typename?: "UpdateDashboardPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  dashboard: Dashboard;
};

/** Autogenerated input type of UpdateFolderName */
export type UpdateFolderNameInput = {
  id: Scalars["ID"];
  name: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateFolderName */
export type UpdateFolderNamePayload = {
  __typename?: "UpdateFolderNamePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  folder: Folder;
};

/** Autogenerated input type of UpdateFolderParent */
export type UpdateFolderParentInput = {
  folderId: Scalars["ID"];
  folderFullName?: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateFolderParent */
export type UpdateFolderParentPayload = {
  __typename?: "UpdateFolderParentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  folder: Folder;
};

/** Autogenerated input type of UpdateGroup */
export type UpdateGroupInput = {
  id: Scalars["ID"];
  name?: Maybe<Scalars["String"]>;
  description?: Maybe<Scalars["String"]>;
  coverImageKey?: Maybe<Scalars["String"]>;
  isPrivate?: Maybe<Scalars["Boolean"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateGroup */
export type UpdateGroupPayload = {
  __typename?: "UpdateGroupPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  group: Group;
};

/** Autogenerated input type of UpdateNoteContent */
export type UpdateNoteContentInput = {
  id: Scalars["ID"];
  newContent: Scalars["String"];
  baseContent: Scalars["String"];
  /** If false, content_updated_at is not touched. */
  touch?: Maybe<Scalars["Boolean"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateNoteContent */
export type UpdateNoteContentPayload = {
  __typename?: "UpdateNoteContentPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  note: Note;
};

/** Autogenerated input type of UpdateNoteFolder */
export type UpdateNoteFolderInput = {
  noteId: Scalars["ID"];
  folderFullName?: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateNoteFolder */
export type UpdateNoteFolderPayload = {
  __typename?: "UpdateNoteFolderPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  note: Note;
};

/** Autogenerated input type of UpdateNote */
export type UpdateNoteInput = {
  id: Scalars["ID"];
  newNote: NoteInput;
  baseNote: NoteInput;
  draft: Scalars["Boolean"];
  /** It will be truncated to 100 characters if exceeded. */
  noteEditMemo?: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateNote */
export type UpdateNotePayload = {
  __typename?: "UpdateNotePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  note: Note;
};

/** Autogenerated input type of UpdateNoteTemplate */
export type UpdateNoteTemplateInput = {
  id: Scalars["ID"];
  name: Scalars["String"];
  title: Scalars["String"];
  content: Scalars["String"];
  groupIds: Array<Scalars["ID"]>;
  folderFullName?: Maybe<Scalars["String"]>;
  coediting: Scalars["Boolean"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateNoteTemplate */
export type UpdateNoteTemplatePayload = {
  __typename?: "UpdateNoteTemplatePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  noteTemplate: NoteTemplate;
};

/** Autogenerated input type of UpdateNoteTitle */
export type UpdateNoteTitleInput = {
  id: Scalars["ID"];
  newTitle: Scalars["String"];
  baseTitle: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateNoteTitle */
export type UpdateNoteTitlePayload = {
  __typename?: "UpdateNoteTitlePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  note: Note;
};

/** Autogenerated input type of UpdateTeamSetting */
export type UpdateTeamSettingInput = {
  inChargeUserId?: Maybe<Scalars["ID"]>;
  organizationKind?: Maybe<OrganizationKind>;
  organizationName?: Maybe<Scalars["String"]>;
  departmentName?: Maybe<Scalars["String"]>;
  phoneNumber?: Maybe<Scalars["String"]>;
  postalCode?: Maybe<Scalars["String"]>;
  country?: Maybe<Scalars["String"]>;
  state?: Maybe<Scalars["String"]>;
  city?: Maybe<Scalars["String"]>;
  streetAddress?: Maybe<Scalars["String"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateTeamSetting */
export type UpdateTeamSettingPayload = {
  __typename?: "UpdateTeamSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UpdateUserNotificationSetting */
export type UpdateUserNotificationSettingInput = {
  kind: UserNotificationSettingKind;
  checked: Scalars["Boolean"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateUserNotificationSetting */
export type UpdateUserNotificationSettingPayload = {
  __typename?: "UpdateUserNotificationSettingPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UploadAttachment */
export type UploadAttachmentInput = {
  /** The name of attachment, typically a filename. */
  name: Scalars["String"];
  data: Scalars["Blob"];
  /** It indicates how and where the attachment is used. */
  kind: AttachmentKind;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UploadAttachment */
export type UploadAttachmentPayload = {
  __typename?: "UploadAttachmentPayload";
  attachment: Attachment;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UploadAttachmentWithDataUrl */
export type UploadAttachmentWithDataUrlInput = {
  /** The name of attachment, typically a filename. */
  name: Scalars["String"];
  /** The data which encoded in Data URL scheme defined in RFC 2397 */
  dataUrl: Scalars["String"];
  /** It indicates how and where the attachment is used. */
  kind: AttachmentKind;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UploadAttachmentWithDataUrl */
export type UploadAttachmentWithDataUrlPayload = {
  __typename?: "UploadAttachmentWithDataUrlPayload";
  attachment: Attachment;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** A user, which is an individual account of a team */
export type User = Node & {
  __typename?: "User";
  account?: Maybe<Scalars["String"]>;
  /** @deprecated Use avatarImage instead */
  avatar: UserAvatarImage;
  avatarImage: UserAvatarImage;
  biography?: Maybe<Scalars["String"]>;
  coverImage?: Maybe<UserCoverImage>;
  /** `email` requires administrative privileges because it is a kind of personal data. */
  email: Scalars["String"];
  groups?: Maybe<GroupConnection>;
  id: Scalars["ID"];
  latestNotes: NoteConnection;
  locale: Scalars["String"];
  path?: Maybe<Scalars["String"]>;
  popularNotes: NoteConnection;
  privateNotes: NoteConnection;
  realName?: Maybe<Scalars["String"]>;
  role: Role;
  shortBio?: Maybe<Scalars["String"]>;
  url?: Maybe<Scalars["String"]>;
};

/** A user, which is an individual account of a team */
export type UserAvatarArgs = {
  size?: Maybe<UserAvatarImageSize>;
  density?: Maybe<Scalars["Int"]>;
};

/** A user, which is an individual account of a team */
export type UserAvatarImageArgs = {
  size?: Maybe<UserAvatarImageSize>;
  density?: Maybe<Scalars["Int"]>;
};

/** A user, which is an individual account of a team */
export type UserCoverImageArgs = {
  size?: Maybe<UserCoverImageSize>;
  density?: Maybe<Scalars["Int"]>;
};

/** A user, which is an individual account of a team */
export type UserGroupsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** A user, which is an individual account of a team */
export type UserLatestNotesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** A user, which is an individual account of a team */
export type UserPopularNotesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** A user, which is an individual account of a team */
export type UserPrivateNotesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** An avatar image of users */
export type UserAvatarImage = {
  __typename?: "UserAvatarImage";
  density: Scalars["Int"];
  height: Scalars["Int"];
  url: Scalars["String"];
  width: Scalars["Int"];
};

/** The size class of user avatar images */
export enum UserAvatarImageSize {
  Small = "SMALL",
  Medium = "MEDIUM",
  Large = "LARGE",
}

/** The connection type for User. */
export type UserConnection = {
  __typename?: "UserConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** A cover image of users */
export type UserCoverImage = {
  __typename?: "UserCoverImage";
  density: Scalars["Int"];
  height: Scalars["Int"];
  key: Scalars["String"];
  size: UserCoverImageSize;
  url: Scalars["String"];
  width: Scalars["Int"];
};

/** The size class of user cover images */
export enum UserCoverImageSize {
  Small = "SMALL",
  Medium = "MEDIUM",
  Original = "ORIGINAL",
}

/** An edge in a connection. */
export type UserEdge = {
  __typename?: "UserEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** The kind of user notification settings */
export enum UserNotificationSettingKind {
  NewsletterMail = "NEWSLETTER_MAIL",
}

/** Autogenerated input type of WatchNote */
export type WatchNoteInput = {
  noteId: Scalars["ID"];
  /** note_update or comment. */
  watchedAction: WatchState;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of WatchNote */
export type WatchNotePayload = {
  __typename?: "WatchNotePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** State of watching note */
export enum WatchState {
  WatchComment = "WATCH_COMMENT",
  WatchNoteUpdate = "WATCH_NOTE_UPDATE",
}
